import os
import base64
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from supabase import create_client, Client
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from googleapiclient.discovery import build

# Load env vars
from dotenv import load_dotenv
load_dotenv()

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_SERVICE_ROLE_KEY = os.getenv("SUPABASE_SERVICE_ROLE_KEY")
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")

supabase: Client = create_client(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

app = FastAPI()

# CORS - adjust origins as needed
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models for request bodies
class GenerateRequest(BaseModel):
    linkedin_url: str
    user_id: str
    # add more fields if needed for generation

class SendEmailRequest(BaseModel):
    to: str
    subject: str
    body: str
    user_id: str

@app.post("/generate")
async def generate_email(req: GenerateRequest):
    # Placeholder for your existing Gemini/GPT + scraping code
    # Return fake response for now
    return {"emails": ["example1@example.com", "example2@example.com"]}

@app.post("/send-email")
async def send_email(req: SendEmailRequest):
    try:
        # Get tokens from Supabase for this user_id
        token_resp = supabase.table("google_tokens").select("*").eq("user_id", req.user_id).single().execute()
        if token_resp.error or not token_resp.data:
            raise HTTPException(status_code=400, detail="No Google OAuth tokens found for user.")
        tokens = token_resp.data

        creds = Credentials(
            None,
            refresh_token=tokens["refresh_token"],
            token_uri="https://oauth2.googleapis.com/token",
            client_id=GOOGLE_CLIENT_ID,
            client_secret=GOOGLE_CLIENT_SECRET,
        )
        creds.refresh(Request())

        service = build("gmail", "v1", credentials=creds)
        raw_message = f"To: {req.to}\nSubject: {req.subject}\n\n{req.body}"
        encoded_message = base64.urlsafe_b64encode(raw_message.encode("utf-8")).decode()

        message = {"raw": encoded_message}

        send_result = service.users().messages().send(userId="me", body=message).execute()

        return {"status": "sent", "messageId": send_result["id"]}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

